import { Callout } from '@/components/docs/Callout';

<PageHeader title="Refund Protection" description="Handle service failures after payment settlement by reporting them for automatic refunds." />

## Why Refunds Matter

In x402 payment flows, payments are settled before service delivery. If your service fails after the payment has been processed, the user deserves a refund. OpenFacilitator's refund protection system automates this by allowing you to report failures, which triggers the facilitator to issue refunds from a dedicated refund wallet.

<Callout type="warning">
**Critical scenario:** Payment succeeded, but service failed. The user has paid, but your service cannot deliver. This is when refund protection is essential.
</Callout>

## Prerequisites

Before using refund protection, ensure:

- **Registered server:** You have an API key from registering your server
- **Funded refund wallet:** The facilitator has a refund wallet funded on your target networks
- **Refunds enabled:** Your facilitator has refunds enabled (check with facilitator admin)

## reportFailure

The `reportFailure` function directly reports a service failure to the facilitator, creating a refund claim.

### Usage

```typescript
import { reportFailure } from '@openfacilitator/sdk';

const result = await reportFailure({
  facilitatorUrl: 'https://api.openfacilitator.io',
  apiKey: 'your-api-key',
  originalTxHash: '0x123...',
  userWallet: '0xabc...',
  amount: '1000000',
  asset: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913',
  network: 'base',
  reason: 'Service unavailable',
});
```

### Parameters

| Name | Type | Required | Description |
| ---- | ---- | -------- | ----------- |
| `facilitatorUrl` | `string` | Yes | The facilitator URL (e.g., `https://api.openfacilitator.io`) |
| `apiKey` | `string` | Yes | Your server API key from registration |
| `originalTxHash` | `string` | Yes | The transaction hash from the original payment settlement |
| `userWallet` | `string` | Yes | The user's wallet address that should receive the refund |
| `amount` | `string` | Yes | The refund amount in atomic units (e.g., `"1000000"` for $1 USDC) |
| `asset` | `string` | Yes | The token contract address (e.g., Base USDC) |
| `network` | `string` | Yes | Network identifier: `"base"`, `"solana"`, or CAIP-2 format |
| `reason` | `string` | No | Optional description of why the service failed |

### Response

```typescript
interface ReportFailureResponse {
  success: boolean;
  claimId?: string;  // Present when success is true
  error?: string;    // Present when success is false
}
```

<Callout type="tip">
**Important:** `reportFailure` does NOT throw exceptions. It returns `success: false` with an error message. Always check the `success` field in the response.
</Callout>

### Example

```typescript
import { reportFailure, type ReportFailureResponse } from '@openfacilitator/sdk';

async function handleServiceFailure(
  txHash: string,
  userWallet: string,
  amount: string
): Promise<void> {
  // Report the failure to the facilitator
  const result: ReportFailureResponse = await reportFailure({
    facilitatorUrl: process.env.FACILITATOR_URL!,
    apiKey: process.env.FACILITATOR_API_KEY!,
    originalTxHash: txHash,
    userWallet: userWallet,
    amount: amount,
    asset: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913', // Base USDC
    network: 'base',
    reason: 'Service temporarily unavailable',
  });

  if (result.success) {
    console.log('Refund claim created:', result.claimId);
    // Log the claim ID for tracking
    // Notify the user that a refund has been initiated
  } else {
    console.error('Failed to create refund claim:', result.error);
    // Handle the error appropriately
    // You may want to retry or alert your team
  }
}
```

## withRefundProtection

The `withRefundProtection` middleware wraps your service handler function to automatically report failures when exceptions are thrown.

### Usage

```typescript
import { withRefundProtection, createPaymentContext } from '@openfacilitator/sdk';

const protectedHandler = withRefundProtection(config, async (context) => {
  // Your service logic here
  // If this throws, failure is automatically reported
});
```

### Configuration

```typescript
interface RefundProtectionConfig {
  apiKey: string;
  facilitatorUrl: string;
  shouldReport?: (error: Error) => boolean;
  onReport?: (claimId: string | undefined, error: Error) => void;
  onReportError?: (reportError: Error, originalError: Error) => void;
}
```

| Field | Type | Required | Description |
| ----- | ---- | -------- | ----------- |
| `apiKey` | `string` | Yes | Your server API key from registration |
| `facilitatorUrl` | `string` | Yes | The facilitator URL |
| `shouldReport` | `(error: Error) => boolean` | No | Custom filter to decide if error should be reported (default: always report) |
| `onReport` | `(claimId: string \| undefined, error: Error) => void` | No | Called when failure is successfully reported |
| `onReportError` | `(reportError: Error, originalError: Error) => void` | No | Called when reporting the failure fails |

### PaymentContext

The `PaymentContext` type contains information about the settled payment:

```typescript
interface PaymentContext {
  transactionHash: string;  // Transaction hash from settlement
  userWallet: string;       // User's wallet address (payer)
  amount: string;           // Payment amount in atomic units
  asset: string;            // Asset/token address
  network: string;          // Network identifier
}
```

<Callout type="tip">
Use the `createPaymentContext` helper to extract `PaymentContext` from your settle response and payment payload.
</Callout>

### Example

```typescript
import {
  OpenFacilitator,
  withRefundProtection,
  createPaymentContext,
  type PaymentPayload,
  type PaymentRequirements,
  type PaymentContext,
} from '@openfacilitator/sdk';

// Initialize facilitator
const facilitator = new OpenFacilitator({
  apiKey: process.env.FACILITATOR_API_KEY!,
  facilitatorUrl: process.env.FACILITATOR_URL!,
});

// Configure refund protection
const refundConfig = {
  apiKey: process.env.FACILITATOR_API_KEY!,
  facilitatorUrl: process.env.FACILITATOR_URL!,
  onReport: (claimId, error) => {
    console.log(`Refund claim created: ${claimId} for error: ${error.message}`);
  },
  onReportError: (reportError, originalError) => {
    console.error(`Failed to report error: ${reportError.message}`);
  },
};

// Define your service handler
async function deliverService(context: PaymentContext): Promise<void> {
  // Your service logic here
  // Example: Generate API key, provision resource, etc.
  const apiKey = await generateApiKey(context.userWallet);

  if (!apiKey) {
    throw new Error('Failed to generate API key');
  }

  // If successful, store transaction for tracking
  await storeTransaction(context.transactionHash, context.userWallet, apiKey);
}

// Wrap handler with refund protection
const protectedDelivery = withRefundProtection(refundConfig, deliverService);

// Handle payment flow
async function handlePayment(
  payment: PaymentPayload,
  requirements: PaymentRequirements
): Promise<void> {
  // Step 1: Verify payment
  const verification = await facilitator.verify(payment, requirements);
  if (!verification.valid) {
    throw new Error(`Invalid payment: ${verification.reason}`);
  }

  // Step 2: Settle payment
  const settlement = await facilitator.settle(payment, requirements);
  if (!settlement.success) {
    throw new Error(`Settlement failed: ${settlement.errorReason}`);
  }

  // Step 3: Create payment context
  const context = createPaymentContext(settlement, payment, requirements);

  // Step 4: Deliver service with refund protection
  try {
    await protectedDelivery(context);
    console.log('Service delivered successfully');
  } catch (error) {
    // Error was already reported by withRefundProtection
    // The original error is re-thrown after reporting
    console.error('Service delivery failed:', error);
    throw error; // Re-throw to caller
  }
}
```

<Callout type="tip">
**When to use which approach:**

- **`reportFailure`:** When you need direct control over error handling or want to report failures in specific scenarios
- **`withRefundProtection`:** When you want automatic failure reporting for any exception thrown during service delivery
</Callout>

## Error Handling

Both `reportFailure` and `withRefundProtection` can encounter various error scenarios:

| Scenario | Error Message | Resolution |
| -------- | ------------- | ---------- |
| Invalid API key | `"Invalid API key"` | Verify your API key is correct and active |
| Inactive server | `"Server is not active"` | Ensure your server is registered and active |
| Refunds disabled | `"Refunds are not enabled for this facilitator"` | Contact facilitator admin to enable refunds |
| Duplicate claim | `"Claim already exists for this transaction"` | This transaction was already reported |
| No refund wallet | `"No refund wallet configured for network: {network}"` | Facilitator needs to configure a refund wallet for this network |

### Error Handling Example

```typescript
import { reportFailure } from '@openfacilitator/sdk';

async function safeReportFailure(
  txHash: string,
  userWallet: string,
  amount: string
): Promise<boolean> {
  const result = await reportFailure({
    facilitatorUrl: process.env.FACILITATOR_URL!,
    apiKey: process.env.FACILITATOR_API_KEY!,
    originalTxHash: txHash,
    userWallet: userWallet,
    amount: amount,
    asset: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913',
    network: 'base',
  });

  if (!result.success) {
    // Handle specific error cases
    if (result.error?.includes('Claim already exists')) {
      console.log('Refund already reported for this transaction');
      return true; // Already handled
    }

    if (result.error?.includes('No refund wallet')) {
      console.error('Refund wallet not configured. Contact facilitator admin.');
      // Alert your team
      return false;
    }

    console.error('Unexpected error reporting failure:', result.error);
    return false;
  }

  console.log('Refund claim created:', result.claimId);
  return true;
}
```

<Callout type="tip">
**Network formats:** Both simple format (`"base"`, `"solana"`) and CAIP-2 format (`"eip155:8453"`) are accepted for the `network` parameter.
</Callout>

## Troubleshooting

### Q: When should I call reportFailure?

**A:** Call `reportFailure` immediately after your service logic fails, but only after the payment has been successfully settled. If settlement fails, there's nothing to refund.

### Q: What happens if I report the same transaction twice?

**A:** The facilitator will return `success: false` with error `"Claim already exists for this transaction"`. This prevents duplicate refunds. You can safely ignore this error if you're implementing retry logic.

### Q: How long does it take for the refund to be processed?

**A:** Refund claims are processed asynchronously by the facilitator. The `reportFailure` call only creates the claim. Actual refund timing depends on the facilitator's processing schedule.

### Q: What if reportFailure itself fails?

**A:** If `reportFailure` returns `success: false`, the failure was not reported. You should log this error and potentially retry. Consider implementing exponential backoff for retries.

### Q: Should I use reportFailure or withRefundProtection?

**A:**
- Use **`withRefundProtection`** if you want automatic failure reporting for any exception
- Use **`reportFailure`** if you need fine-grained control over when failures are reported (e.g., only certain error types)

### Q: Can I report partial refunds?

**A:** Yes. The `amount` parameter in `reportFailure` can be any value up to the original payment amount. This is useful if your service was partially delivered.

### Q: What network formats are supported?

**A:** Both simple format (`"base"`, `"solana"`) and CAIP-2 format (`"eip155:8453"`, `"solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp"`) are supported.
