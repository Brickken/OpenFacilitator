---
phase: 20-recurring-payment-engine
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/server/src/db/subscription-payments.ts
  - packages/server/src/db/index.ts
  - packages/server/src/services/subscription-billing.ts
autonomous: true

must_haves:
  truths:
    - "Payment attempts are logged with chain, amount, status, and tx hash"
    - "Preferred chain is tried first, fallback to alternate on insufficient balance"
    - "Payment service can deduct from either Solana or Base wallet"
  artifacts:
    - path: "packages/server/src/db/subscription-payments.ts"
      provides: "Subscription payment logging CRUD"
      exports: ["createSubscriptionPayment", "getSubscriptionPaymentsByUser", "SubscriptionPayment"]
    - path: "packages/server/src/services/subscription-billing.ts"
      provides: "Payment processing with fallback logic"
      exports: ["processSubscriptionPayment", "PaymentResult"]
  key_links:
    - from: "packages/server/src/services/subscription-billing.ts"
      to: "packages/server/src/db/subscription-payments.ts"
      via: "createSubscriptionPayment call"
      pattern: "createSubscriptionPayment"
    - from: "packages/server/src/services/subscription-billing.ts"
      to: "packages/server/src/db/user-preferences.ts"
      via: "getUserPreference for chain selection"
      pattern: "getUserPreference"
---

<objective>
Create subscription payment database layer and billing service with multi-chain fallback logic.

Purpose: Enable recurring payments from user wallets with proper logging and chain preference fallback behavior.
Output: Database functions for payment logging, billing service that processes payments from preferred chain with fallback to alternate.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-recurring-payment-engine/20-CONTEXT.md

# Prior phase context
@.planning/phases/19-chain-preference-logic/19-01-SUMMARY.md
@.planning/phases/18-multi-chain-wallet-infrastructure/18-01-SUMMARY.md

# Existing code patterns
@packages/server/src/db/subscriptions.ts
@packages/server/src/services/wallet.ts
@packages/server/src/db/user-preferences.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create subscription_payments database layer</name>
  <files>packages/server/src/db/subscription-payments.ts, packages/server/src/db/index.ts</files>
  <action>
Create `packages/server/src/db/subscription-payments.ts` with:

1. SubscriptionPayment interface:
   - id: string (UUID)
   - user_id: string (FK to user)
   - subscription_id: string | null (FK to subscriptions, null for failed attempts)
   - amount: number (USDC in 6 decimals)
   - chain: 'solana' | 'base'
   - status: 'success' | 'failed' | 'pending'
   - tx_hash: string | null
   - error_message: string | null
   - is_fallback: boolean (true if this was alternate chain attempt)
   - created_at: string

2. Functions:
   - createSubscriptionPayment(userId, amount, chain, status, txHash?, errorMessage?, subscriptionId?, isFallback?) -> SubscriptionPayment
   - getSubscriptionPaymentsByUser(userId, limit?, offset?) -> SubscriptionPayment[]
   - getSubscriptionPaymentById(id) -> SubscriptionPayment | null
   - getRecentPaymentAttempts(userId, hours: number) -> SubscriptionPayment[] (for retry logic)

Update `packages/server/src/db/index.ts`:
- Add subscription_payments table schema in CREATE TABLE section
- Add indexes on user_id, status, created_at
- Export from subscription-payments.ts

Schema:
```sql
CREATE TABLE IF NOT EXISTS subscription_payments (
  id TEXT PRIMARY KEY,
  user_id TEXT NOT NULL REFERENCES "user" ("id") ON DELETE CASCADE,
  subscription_id TEXT REFERENCES subscriptions(id) ON DELETE SET NULL,
  amount INTEGER NOT NULL,
  chain TEXT NOT NULL CHECK (chain IN ('solana', 'base')),
  status TEXT NOT NULL CHECK (status IN ('success', 'failed', 'pending')),
  tx_hash TEXT,
  error_message TEXT,
  is_fallback INTEGER NOT NULL DEFAULT 0,
  created_at TEXT NOT NULL DEFAULT (datetime('now'))
);

CREATE INDEX IF NOT EXISTS idx_subscription_payments_user ON subscription_payments(user_id);
CREATE INDEX IF NOT EXISTS idx_subscription_payments_status ON subscription_payments(status);
CREATE INDEX IF NOT EXISTS idx_subscription_payments_created ON subscription_payments(created_at);
```
  </action>
  <verify>TypeScript compiles: `cd packages/server && npx tsc --noEmit`</verify>
  <done>subscription_payments table schema exists, CRUD functions exported</done>
</task>

<task type="auto">
  <name>Task 2: Create subscription billing service with fallback logic</name>
  <files>packages/server/src/services/subscription-billing.ts</files>
  <action>
Create `packages/server/src/services/subscription-billing.ts`:

1. PaymentResult type:
   - success: boolean
   - txHash?: string
   - chain?: 'solana' | 'base'
   - error?: string
   - insufficientBothChains?: boolean
   - usedFallback?: boolean

2. processSubscriptionPayment(userId: string) -> Promise<PaymentResult>:
   Flow:
   a. Get user's preferred chain from getUserPreference (default 'solana' if none)
   b. Get both wallets via getAllWalletsForUser
   c. Get balance for preferred chain wallet (getUSDCBalance or getBaseUSDCBalance)
   d. If preferred chain has >= SUBSCRIPTION_PRICING.starter:
      - Decrypt private key with decryptUserPrivateKey(userId, chain)
      - Make payment via makeX402Payment to X402_JOBS_PAYMENT_URL
      - Log payment via createSubscriptionPayment with is_fallback=false
      - If success: create/extend subscription, return success
      - If fail (not insufficient balance): log error, return failure
   e. If preferred chain insufficient OR payment failed due to insufficient:
      - Try alternate chain (if wallet exists)
      - Get alternate chain balance
      - If sufficient: attempt payment, log with is_fallback=true
      - If success: create/extend subscription, return success with usedFallback=true
   f. If both chains insufficient:
      - Log failed attempt for preferred chain
      - Return { success: false, insufficientBothChains: true }

3. Helper: getAlternateChain(chain: 'solana' | 'base') -> 'solana' | 'base'

Import from existing:
- SUBSCRIPTION_PRICING from '../db/subscriptions.js'
- getUserPreference from '../db/user-preferences.js'
- getAllWalletsForUser, decryptUserPrivateKey, getUSDCBalance, getBaseUSDCBalance from './wallet.js'
- makeX402Payment from './x402-client.js'
- createSubscription, getActiveSubscription, extendSubscription from '../db/subscriptions.js'
- createSubscriptionPayment from '../db/subscription-payments.js'

Use X402_JOBS_PAYMENT_URL from env (same as subscriptions.ts route uses).
  </action>
  <verify>TypeScript compiles: `cd packages/server && npx tsc --noEmit`</verify>
  <done>processSubscriptionPayment function handles preferred chain + fallback, logs all attempts</done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors
2. subscription_payments table schema is correct SQLite syntax
3. Billing service imports all required dependencies
4. Fallback logic correctly identifies alternate chain
</verification>

<success_criteria>
- subscription_payments table can store payment attempts with chain, status, fallback flag
- processSubscriptionPayment tries preferred chain first, falls back to alternate
- All payment attempts (success and failure) are logged to subscription_payments
- Service correctly extends subscription on successful payment
</success_criteria>

<output>
After completion, create `.planning/phases/20-recurring-payment-engine/20-01-SUMMARY.md`
</output>
